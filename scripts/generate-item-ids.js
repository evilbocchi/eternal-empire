#!/usr/bin/env node

import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

/**
 * Node.js script to generate a TypeScript union type of all item IDs
 * from the Roblox TypeScript project structure.
 */

const ITEMS_DIR = path.join(__dirname, "../src/shared/items");
const OUTPUT_FILE = path.join(__dirname, "../src/ItemId.d.ts");

/**
 * Recursively find all TypeScript files in a directory
 * @param {string} dir - Directory to search
 * @param {string[]} files - Array to collect file paths
 * @returns {string[]} Array of file paths
 */
function findTsFiles(dir, files = []) {
    if (!fs.existsSync(dir)) {
        console.error(`Directory does not exist: ${dir}`);
        return files;
    }

    const entries = fs.readdirSync(dir, { withFileTypes: true });
    
    for (const entry of entries) {
        const fullPath = path.join(dir, entry.name);
        
        if (entry.isDirectory()) {
            findTsFiles(fullPath, files);
        } else if (entry.isFile() && entry.name.endsWith(".ts")) {
            files.push(fullPath);
        }
    }
    
    return files;
}

/**
 * Extract item ID from a TypeScript file path
 * In Roblox TS, script.Name corresponds to the file name without extension
 * @param {string} filePath - Path to the TypeScript file
 * @returns {string|null} Item ID or null if not a valid item file
 */
function extractItemId(filePath) {
    const fileName = path.basename(filePath, ".ts");
    
    // Skip the main Items.ts file and any shop files
    if (fileName === "Items" || fileName.includes("Shop")) {
        return null;
    }
    
    // Read file content to verify it exports an Item
    try {
        const content = fs.readFileSync(filePath, "utf8");
        
        // Check if the file exports an Item (looks for "new Item(script.Name)" pattern)
        if (content.includes("new Item(script.Name)") || content.includes("export = new Item(")) {
            return fileName;
        }
    } catch (error) {
        // Silently ignore files that can't be read
    }
    
    return null;
}

/**
 * Generate the TypeScript ItemId union type
 */
function generateItemIdType() {
    // eslint-disable-next-line no-console
    console.log("üîç Scanning for item files...");
    
    const tsFiles = findTsFiles(ITEMS_DIR);
    const itemIds = [];
    
    for (const filePath of tsFiles) {
        const itemId = extractItemId(filePath);
        if (itemId) {
            itemIds.push(itemId);
        }
    }
    
    // Sort item IDs alphabetically for consistent output
    itemIds.sort();
    
    // eslint-disable-next-line no-console
    console.log(`üìä Found ${itemIds.length} item files`);
    
    if (itemIds.length === 0) {
        // eslint-disable-next-line no-console
        console.error("‚ùå No item files found!");
        process.exit(1);
    }
    
    // Generate the TypeScript content
    const typeDefinition = itemIds
        .map((id) => `    | "${id}"`)
        .join("\n");
    
    const tsContent = `/**
 * Auto-generated union type of all item IDs in the game.
 *
 * This file is generated by scripts/generate-item-ids.js
 * Do not edit this file manually - run the script to regenerate it.
 *
 * Generated on: ${new Date().toISOString()}
 * Total items: ${itemIds.length}
 */
export type ItemId =
${typeDefinition};

export default ItemId;
`;

    // Ensure output directory exists
    const outputDir = path.dirname(OUTPUT_FILE);
    if (!fs.existsSync(outputDir)) {
        fs.mkdirSync(outputDir, { recursive: true });
    }
    
    // Write the generated type to file
    fs.writeFileSync(OUTPUT_FILE, tsContent, "utf8");
    
    // eslint-disable-next-line no-console
    console.log(`‚úÖ Generated ItemId type with ${itemIds.length} items`);
    // eslint-disable-next-line no-console
    console.log(`üìÅ Output written to: ${path.relative(process.cwd(), OUTPUT_FILE)}`);
    
    // Show first few and last few items as a preview
    const previewCount = 5;
    if (itemIds.length > previewCount * 2) {
        // eslint-disable-next-line no-console
        console.log(`\nüîç Preview (first ${previewCount}):`);
        itemIds.slice(0, previewCount).forEach((id) => {
            // eslint-disable-next-line no-console
            console.log(`   - "${id}"`);
        });
        // eslint-disable-next-line no-console
        console.log("   ...");
        // eslint-disable-next-line no-console
        console.log(`üîç Preview (last ${previewCount}):`);
        itemIds.slice(-previewCount).forEach((id) => {
            // eslint-disable-next-line no-console
            console.log(`   - "${id}"`);
        });
    } else {
        // eslint-disable-next-line no-console
        console.log(`\nüîç All items:`);
        itemIds.forEach((id) => {
            // eslint-disable-next-line no-console
            console.log(`   - "${id}"`);
        });
    }
}

// Run the script
// In ES modules, check if this file was run directly
const isMainModule = process.argv[1] && path.resolve(process.argv[1]) === path.resolve(fileURLToPath(import.meta.url));

if (isMainModule) {
    try {
        generateItemIdType();
    } catch (error) {
        // eslint-disable-next-line no-console
        console.error("‚ùå Error generating ItemId type:", error.message);
        process.exit(1);
    }
}

export { generateItemIdType, findTsFiles, extractItemId };